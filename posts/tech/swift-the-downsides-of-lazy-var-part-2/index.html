<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta property="og:title" content="Swift: The downsides of lazy var (part 2)">
      <title>Thuyen&#39;s corner</title>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/default.min.css">
      <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
      
      <link rel="stylesheet" href="https://trinhngocthuyen.github.io/sass/main.7c9da60ff2d0ede050060cc37446d405a6ebc67b1b72688fd9329eba535d7f72.css">

      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-69597239-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </head>
  <body class="" data-url="/posts/tech/swift-the-downsides-of-lazy-var-part-2/">
    <nav role="navigation">
  <header role="banner">
    <h1 id="logo">
      <a href="/">Thuyen&#39;s corner</a>
    </h1>
  </header>
  <div id="menu-toggle" class="menu-toggle">
    <span class='open'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="3" y1="12" x2="21" y2="12" />
  <line x1="3" y1="6" x2="21" y2="6" />
  <line x1="3" y1="18" x2="21" y2="18" />
  
</svg>
</span>
    <span class='close'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
  
</svg>
</span>
  </div>
  <ul>
    
    <li><a href="/posts/tech">Tech</a></li>
    
    <li><a href="/posts/misc">Misc (Tạp bút)</a></li>
    
    <li><a href="/about">About</a></li>
    
  </ul>
</nav>

<script src="/scripts/menu.js"></script>
    <main role="main">
<article class="page">
  <header>
  
  <h1>Swift: The downsides of lazy var (part 2)</h1>
  
  
  <div class="metadata">
  <span>2018, Jun 1</span>
</div>
  
</header>
  <p>Continue from the <a href="/tech/swift-the-downsides-of-lazy-var-part-1">previous post</a>, we will look into a few problems when working with lazy var.</p>
<h3 id="problems">Problems</h3>
<h4 id="problem-1-not-working-smoothly-with-structs">Problem 1: not working smoothly with structs</h4>
<p>Since the getter of lazy var is mutating, using it with structs sometimes requires extra work. For example, this code below does not compile:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Person</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">name</span> <span class="p">=</span> <span class="s">&#34;thuyen&#34;</span>
	<span class="kd">var</span> <span class="nv">alias</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span> <span class="p">}</span> 	<span class="c1">// error: Cannot use mutating getter on immutable</span>
<span class="p">}</span>
</code></pre></div><p>To make this code work, we have to explicitly declare <code>getter</code> of <code>alias</code> as <code>mutating</code>. But personally, I would rather not make an object mutable just in order to access a specific property.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="nc">Person</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">name</span> <span class="p">=</span> <span class="s">&#34;thuyen&#34;</span>
	<span class="kd">var</span> <span class="nv">alias</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
		<span class="kr">mutating</span> <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span> <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Another approach is to wrap lazy var inside a class <code>LazyBox</code>, like in <a href="https://oleb.net/blog/2015/12/lazy-properties-in-structs-swift">this article</a>. We will later use this approach as we can handle more issues such as concurrency.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kr">final</span> <span class="kd">class</span> <span class="nc">LazyBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="kd">var</span> <span class="nv">_value</span><span class="p">:</span> <span class="n">T</span><span class="p">?</span>
	<span class="kd">private</span> <span class="kd">let</span> <span class="nv">compute</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">T</span>
	<span class="kd">init</span><span class="p">(</span><span class="kc">_</span> <span class="n">compute</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
		<span class="kc">self</span><span class="p">.</span><span class="n">compute</span> <span class="p">=</span> <span class="n">compute</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
		<span class="k">if</span> <span class="kd">let</span> <span class="nv">_value</span> <span class="p">=</span> <span class="n">_value</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span> <span class="p">}</span>
		<span class="kd">let</span> <span class="nv">v</span> <span class="p">=</span> <span class="n">compute</span><span class="p">()</span>
		<span class="n">_value</span> <span class="p">=</span> <span class="n">v</span>
		<span class="k">return</span> <span class="n">v</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Person</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="kd">let</span> <span class="nv">_name</span> <span class="p">=</span> <span class="n">LazyBox</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">{</span> <span class="s">&#34;thuyen&#34;</span> <span class="p">}</span>
	<span class="kd">var</span> <span class="nv">alias</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_name</span><span class="p">.</span><span class="n">value</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="problem-2-concurrency">Problem 2: concurrency</h4>
<p>Another problem is that <code>lazy var</code> is not thread-safe which means the closure can get executed multiple times due to accesses from different threads. This is also mentioned in the Apple documentation:</p>
<blockquote>
<p>If a property marked with the <code>lazy</code> modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.</p>
</blockquote>
<p>To prevent race condition, a simple implementation is to lock every read to the value:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kr">final</span> <span class="kd">class</span> <span class="nc">LazyBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="kd">let</span> <span class="nv">lock</span><span class="p">:</span> <span class="n">Synchronizing</span> <span class="p">=</span> <span class="n">NSLock</span><span class="p">()</span>
	<span class="kd">private</span> <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">_lazyValue</span><span class="p">:</span> <span class="n">T</span> <span class="p">=</span> <span class="n">compute</span><span class="p">()</span>
	<span class="p">...</span>
	<span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">lock</span><span class="p">.</span><span class="n">sync</span> <span class="p">{</span> <span class="n">_lazyValue</span> <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="nc">Locking</span> <span class="p">{</span>
	<span class="kd">func</span> <span class="nf">lock</span><span class="p">()</span>
	<span class="kd">func</span> <span class="nf">unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="nc">Synchronizing</span> <span class="p">{</span>
	<span class="kd">func</span> <span class="nf">sync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">execute</span><span class="p">:</span> <span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="n">T</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Locking</span> <span class="p">{</span>
	<span class="kd">func</span> <span class="nf">sync</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">execute</span><span class="p">:</span> <span class="p">()</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">)</span> <span class="kr">rethrows</span> <span class="p">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="p">{</span> <span class="n">unlock</span><span class="p">()</span> <span class="p">}</span>
		<span class="n">lock</span><span class="p">()</span>
		<span class="k">return</span> <span class="k">try</span> <span class="n">execute</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Let&#39;s use NSLock for simplicity. Alternatives: DispatchQueue, pthread_mutex_t, semaphore...</span>
<span class="kd">extension</span> <span class="nc">NSLock</span><span class="p">:</span> <span class="n">Locking</span><span class="p">,</span> <span class="n">Synchronizing</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>Now, it works as expected. However, the computation should only occur in the first read access. Locking every read will hurt performance a bit. Therefore, a better implementation is to lock the computation instead.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kr">final</span> <span class="kd">class</span> <span class="nc">LazyBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
		<span class="k">if</span> <span class="kd">let</span> <span class="nv">_value</span> <span class="p">=</span> <span class="n">_value</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span> <span class="p">}</span>
		<span class="k">return</span> <span class="n">lock</span><span class="p">.</span><span class="n">sync</span> <span class="p">{</span>
			<span class="c1">// Perform computation here</span>
			<span class="p">...</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Note that performing computation more than once is still fine as long as they are synchronous and later computation reuses the result of previous ones.
We know for sure that in the next execution inside <code>lock.sync</code>, we definitely have <code>_value</code> computed. Then we can reuse that result, like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kr">final</span> <span class="kd">class</span> <span class="nc">LazyBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
	<span class="p">...</span>
	<span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
		<span class="k">if</span> <span class="kd">let</span> <span class="nv">_value</span> <span class="p">=</span> <span class="n">_value</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span> <span class="p">}</span>
		<span class="k">return</span> <span class="n">lock</span><span class="p">.</span><span class="n">sync</span> <span class="p">{</span>
			<span class="c1">// Check again if the value is already computed (from the first one get called)</span>
			<span class="k">if</span> <span class="kd">let</span> <span class="nv">_value</span> <span class="p">=</span> <span class="n">_value</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_value</span> <span class="p">}</span>
			<span class="kd">let</span> <span class="nv">v</span> <span class="p">=</span> <span class="n">compute</span><span class="p">()</span>
			<span class="n">_value</span> <span class="p">=</span> <span class="n">v</span>
			<span class="k">return</span> <span class="n">v</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="benchmark">Benchmark</h3>
<p>I ran a performance test for the two implementations (locking computation only vs. locking every read).
The result shows a significant performance gain for the former one (0.002s as compared to 0.065s). The code for the benchmark can be found <a href="https://gist.github.com/trinhngocthuyen/c51e4025658510b63f28b30596714f55">here</a>.</p>

  <div class="entry-footer">
  
<div class="categories">
  <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>

  
  <a href="/categories/tech" class="category">tech</a>
  
</div>

  
<div class="tags">
  <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>

  
  <a href="/tags/ios" class="tag">ios</a>
  
  <a href="/tags/swift" class="tag">swift</a>
  
</div>

</div>
</article>


<nav class='entry-nav'><div class='prev-entry'>
    <a href='/posts/tech/swift-the-downsides-of-lazy-var-part-1/'>Swift: The downsides of lazy var (part 1)</a>
  </div><div class='next-entry'>
    <a href='/posts/tech/random-thoughts-on-being-a-ci-engineer/'>Random thoughts on being a CI engineer</a>
  </div></nav>


<section id='comments' class='comments'>
  
  
  <div class="container">
    <div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v5.0"></script>
<div class="share">
  <div class="fb-like" data-href="https://trinhngocthuyen.github.io/posts/tech/swift-the-downsides-of-lazy-var-part-2/" data-width="" data-layout="standard" data-action="like" data-share="true"></div>
</div>

  </div>
  
  
  <div class="container">
    
  </div>
</section>


</main></body>
</html>