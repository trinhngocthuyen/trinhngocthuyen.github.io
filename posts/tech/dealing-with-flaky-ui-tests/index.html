<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta property="og:title" content="Dealing With Flaky UI Tests in iOS">
      <title>Thuyen&#39;s corner</title>
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/default.min.css">
      <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
      
      <link rel="stylesheet" href="https://trinhngocthuyen.github.io/sass/main.7c9da60ff2d0ede050060cc37446d405a6ebc67b1b72688fd9329eba535d7f72.css">

      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-69597239-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </head>
  <body class="" data-url="/posts/tech/dealing-with-flaky-ui-tests/">
    <nav role="navigation">
  <header role="banner">
    <h1 id="logo">
      <a href="/">Thuyen&#39;s corner</a>
    </h1>
  </header>
  <div id="menu-toggle" class="menu-toggle">
    <span class='open'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="3" y1="12" x2="21" y2="12" />
  <line x1="3" y1="6" x2="21" y2="6" />
  <line x1="3" y1="18" x2="21" y2="18" />
  
</svg>
</span>
    <span class='close'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
  
</svg>
</span>
  </div>
  <ul>
    
    <li><a href="/posts/tech">Tech</a></li>
    
    <li><a href="/posts/misc">Misc (Tạp bút)</a></li>
    
    <li><a href="/about">About</a></li>
    
  </ul>
</nav>

<script src="/scripts/menu.js"></script>
    <main role="main">
<article class="page">
  <header>
  
  <h1>Dealing With Flaky UI Tests in iOS</h1>
  
  
  <div class="metadata">
  <span>2022, Jun 25</span>
</div>
  
</header>
  <h2 id="1-introduction">1. Introduction</h2>
<p>UI testing is a test technique, besides unit testing, to ensure product quality. While unit testing focuses on small portions (or units) of the system, UI testing aims to cover a wider user journey in the app. This testing technique helps engineers gain more confidence when developing, refactoring, and shipping the products to users. In the context of iOS development, UI testing plays a key role in product quality as the form of a feature shipped to users is usually through what they see on the app.</p>
<p>Despite its benefits, UI testing is also a source of headache when it comes to flakiness. UI tests have a higher level of integration (ie. many components are involved) as compared to unit tests. Therefore, flakiness is always part of the system.</p>
<p>In this post, we are going to discover what fators contribute to test flakiness and how to cope with them.</p>
<h2 id="2-background">2. Background</h2>
<h3 id="21-what-is-test-flakiness">2.1. What is Test Flakiness?</h3>
<p>A flaky test is a test that produces different results (passed or failed) each time it runs.</p>
<h3 id="22-what-is-ui-testing">2.2. What is UI Testing?</h3>
<p>UI testing is a technique to test features of a software like how a user interacts with that software. This involves testing visual elements of the software. A test action could be a UI interaction (ex. tapping a button, typing an input, etc), or an assertion (ex. checking if a text is displayed).</p>
<p>A typical UI test flow in iOS apps would be:</p>
<ul>
<li>Launch the app.</li>
<li>In the home screen, tap the avatar icon to open the profile screen.</li>
<li>In the profile screen, check the presence of the name, email of the user.</li>
<li>Tap the edit icon to edit the profile, then type the new first name, last name.</li>
<li>Tap save, then expect to see the updated info.</li>
</ul>
<h3 id="23-two-apps-in-ui-testing">2.3. Two Apps in UI Testing</h3>
<p>UI testing in iOS involves two apps:</p>
<ul>
<li><strong>Host app</strong>, sometimes called <em>app under test</em> (AUT): The app we want to test. The test workflows we expect to see occur in this app.</li>
<li><strong>Runner app</strong>: The app that performs test actions. The code to tap buttons, assert labels In the test case belongs to this runner app, not the host app.</li>
</ul>
<p>Note that these 2 apps are sandboxed and running in two different processes. Even if a framework (imported in both apps) has a global variable (ex. <code>MyFramework.MyClass.myGlobalVariable</code>), that variable is NOT shared across the two apps.</p>
<p>We can think of a UI test action as an <a href="https://en.wikipedia.org/wiki/Inter-process_communication">inter-process communication</a> between the runner app and the host app. What happens under the hood during a test execution are as follows:</p>
<ul>
<li>The runner app requests/queries for elements of the host app.</li>
<li>The host app receives the request and returns the matching elements with some attributes (identifier, text, enabled, hittable&hellip;).</li>
<li>The runner app requests to tap a specific element.</li>
<li>The host app receives the request and performs the tap action on that element.</li>
<li>&hellip;</li>
</ul>
<p>Some UI test actions such as querying elements, or tapping/scrolling/toggling elements are supported by the XCTest framework. To perform more complicated actions such as triggering a database cleanup, we might need to implement the inter-process communication ourselves. Using TCP socket is a common choice for this purpose.</p>
<h3 id="24-polling-checks-in-ui-testing">2.4. Polling-Checks in UI Testing</h3>
<p>UI elements do not immediately show up on the screen. The delayed display could be due to animations, or network. Therefore, it is a common practice to do polling-checks in UI testing. The pseudo-implementation would be like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">waitForExistence</span><span class="p">(</span><span class="kc">_</span> <span class="n">element</span><span class="p">:</span> <span class="n">XCUIElement</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">XCUIElement</span><span class="p">?</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nv">found</span><span class="p">:</span> <span class="n">XCUIElement</span><span class="p">?</span>
  <span class="k">while</span> <span class="n">notExceedTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">element</span><span class="p">.</span><span class="n">exist</span> <span class="p">{</span>
      <span class="n">found</span> <span class="p">=</span> <span class="n">element</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">pollingFrequency</span><span class="p">)</span> <span class="c1">// &lt;-- wait a bit (ex. 0.1s), then check again</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">found</span>
<span class="p">}</span>
</code></pre></div><p>In each iteration, we check the presence of an element. If not found, we wait a bit then check again. If the condition does not satisfy within a certain timeout, we throw a test failure.</p>
<h3 id="25-end-to-end-testing-vs-workflow-ui-testing">2.5. End-To-End Testing vs. Workflow UI Testing</h3>
<p>Testing mobile app flows usually includes both backend (BE) and frontend (FE). The system under testing (SUT) in mobile testing is the frontend, ie. the mobile app.</p>
<p>When using the real backend in UI testing, this approach is called &ldquo;<strong>end-to-end (E2E) testing</strong>&rdquo;. It involves testing the system from beginning to end (both backend and frontend). Usually, E2E testing is under automation QAs' maintenance. Meanwhile, UI testing with a mock backend just cares about the frontend. This approach is to ensure app behaves correctly given a stable mock backend. To avoid the ambiguity, let&rsquo;s call this approach &ldquo;<strong>workflow UI testing</strong>&rdquo;.</p>
<p>In this post, we scope the discussion to workflow UI testing only. We will talk about E2E testing in some upcoming posts. Note that the flakiness we are going to discuss also persists in E2E testing.</p>
<h2 id="3-contributing-factors-to-flakiness">3. Contributing Factors to Flakiness</h2>
<h3 id="31-shared-environments">3.1. Shared Environments</h3>
<p>Shared resources imply flakiness. Such resources for testing could be mocks/stubs, database, etc.</p>
<p>For UI testing in iOS, the simulator that runs tests can also be seen as shared resources. This is why the execution of a test might be affected by the execution of others on the same simulator. For example, if we toggle a (shared/global) flag in one test and forget to reset it after the execution, this flag might cause failures in the subsequent executions. Keep in mind that flakiness due to shared environments might come from both host app and runner app implementation.</p>
<p>To have better test stability, we need to <strong>ensure a clean state</strong> before and after running a test by resetting cache, database, flags, keychains, etc. Note that uninstalling the app beforehand does not magically put the app into a clean state as some data is not bound to app&rsquo;s life cycle. For example, even if the app is uninstalled, keychain values belonging to that app still persist (see: <a href="https://developer.apple.com/forums/thread/22874?answerId=75464022#75464022">here</a>). This might lead to unexpected behaviors in the next time we install and launch the app for testing. Therefore, it is necessary to have a backdoor for testing to thoroughly put the app in a clean state.</p>
<h3 id="32-auto-dismissable-components">3.2. Auto-dismissable Components</h3>
<p>A challenge when testing auto-dismissable components is that we need to check all the details (in such components) <strong>in time</strong>. Those commonly used components are snackbars, or toast messages. They normally persist for one to a few seconds. While a UI check only takes up a fraction of a second, many checks in the component might exceed the appointed time. Note that when running tests in parallel (ex. 4 simulators), it usually takes a bit longer time than usual to perform a UI check due to high CPU usage.</p>
<img src="/images/ios/auto_dismissable_banner.png" width=375>
<figcaption>Fig. Auto-dismissable banner.</figcaption>
<p>There are a few actions we can take to tackle this problem.</p>
<p>First, we can <strong>inject the display duration</strong> of those components when running UI tests. For example, instead of showing snackbars for 1s, we can increase the duration to 3s.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// In the app target</span>
<span class="kd">func</span> <span class="nf">showSnackBar</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kd">let</span> <span class="nv">defaultDuration</span> <span class="p">=</span> <span class="mf">1.0</span>
  <span class="kd">let</span> <span class="nv">injectedDuration</span> <span class="p">=</span> <span class="n">ProcessInfo</span><span class="p">.</span><span class="n">processInfo</span><span class="p">.</span><span class="n">environment</span><span class="p">[</span><span class="s">&#34;SNACKBAR_DURATION&#34;</span><span class="p">].</span><span class="n">flatMap</span> <span class="p">{</span> <span class="nb">Double</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
  <span class="kd">let</span> <span class="nv">duration</span> <span class="p">=</span> <span class="n">injectedDuration</span> <span class="p">??</span> <span class="n">defaultDuration</span>
  <span class="n">_show</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">text</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// In the test target</span>
<span class="kd">class</span> <span class="nc">BaseTestCase</span><span class="p">:</span> <span class="n">XCTestCase</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nv">app</span> <span class="p">=</span> <span class="n">XCUIApplication</span><span class="p">()</span>
  <span class="kr">override</span> <span class="kd">func</span> <span class="nf">setUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">setUp</span><span class="p">()</span>
    <span class="n">app</span><span class="p">.</span><span class="n">launchEnvironment</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#34;SNACKBAR_DURATION&#34;</span><span class="p">:</span> <span class="s">&#34;4] // &lt;-- inject the value
</span><span class="s">    app.launch()
</span><span class="s">  }
</span><span class="s">}
</span></code></pre></div><p>Second, if there are many checks in a UI component, we can <strong>combine several checks</strong> in one query. Let say, we wish to see 10 elements on the screen. Instead of sequentially checking each element, we can check all elements together in one poll iteration. The polling-check above can be justified for the multiple elements as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">waitForExistence</span><span class="p">(</span><span class="kc">_</span> <span class="n">elements</span><span class="p">:</span> <span class="p">[</span><span class="n">XCUIElement</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">XCUIElement</span><span class="p">]</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">while</span> <span class="n">notExceedTimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">elements</span><span class="p">.</span><span class="n">allSatisfy</span><span class="p">({</span> <span class="nv">$0</span><span class="p">.</span><span class="n">exist</span> <span class="p">})</span> <span class="p">{</span> <span class="c1">// &lt;-- combine the checks</span>
      <span class="p">...</span>
      <span class="k">break</span>
    <span class="p">}</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">pollFrequency</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div><img src="/images/ios/ui_test_combine_checks.png" width=600>
<figcaption>Fig. Combining several checks to reduce the total wait time.</figcaption>
<h3 id="33-animations">3.3. Animations</h3>
<p>Regarding overhead time of an animation, it is not that much as one normally takes less than 2s to finish. We just need to increase the timeout (ex. to 10s) for element checks to gain better stability.</p>
<p>However, animations do have a side effect when running UI tests. This is due to an intentional behavior of the XCTest framework. To be more specific, when running tests, the XCTest framework <strong>waits for the host app to idle</strong> before performing UI actions/checks. The app is not in the idle state as long as an animation is still on-going. This explains why we sometimes see tons of <em>&ldquo;Waiting for app to idle&rdquo;</em> in the console log.</p>
<p>Take the &ldquo;loading/shimmery UI&rdquo; for example. This kind of animations happens continuously until the loaded data is presented. Therefore, even if there are contents elsewhere on the screen, the animation still keeps the test from asserting elements.</p>
<img src="/images/ios/shimmering.png" width=375>
<figcaption>Fig. Shimmery UI, usually with repeated animations.</figcaption>
<p>Another problematic case is when we have animations on auto-dismissable components. The animations prolong the wait time mentioned above. As a result, by the time we check elements on such a component, they are already dismissed.</p>
<p>There are two common approaches to overcome this problem.</p>
<p>First, we can just <strong>disable animations</strong> when running UI tests.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// In the app target</span>
<span class="kd">class</span> <span class="nc">AppDelegate</span><span class="p">:</span> <span class="n">UIResponder</span><span class="p">,</span> <span class="n">UIApplicationDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="n">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="n">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="n">UIApplication</span><span class="p">.</span><span class="n">LaunchOptionsKey</span><span class="p">:</span> <span class="nb">Any</span><span class="p">]?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ProcessInfo</span><span class="p">.</span><span class="n">processInfo</span><span class="p">.</span><span class="n">environment</span><span class="p">[</span><span class="s">&#34;IS_UI_TEST&#34;</span><span class="p">]</span> <span class="p">==</span> <span class="s">&#34;YES&#34;</span> <span class="p">{</span>
      <span class="n">UIView</span><span class="p">.</span><span class="n">setAnimationsEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// In the test target</span>
<span class="kd">class</span> <span class="nc">BaseTestCase</span><span class="p">:</span> <span class="n">XCTestCase</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nv">app</span> <span class="p">=</span> <span class="n">XCUIApplication</span><span class="p">()</span>
  <span class="kr">override</span> <span class="kd">func</span> <span class="nf">setUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">setUp</span><span class="p">()</span>
    <span class="n">app</span><span class="p">.</span><span class="n">launchEnvironment</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#34;IS_UI_TEST&#34;</span><span class="p">:</span> <span class="s">&#34;YES&#34;</span><span class="p">]</span> <span class="c1">// &lt;-- inject the value</span>
    <span class="n">app</span><span class="p">.</span><span class="n">launch</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>This approach has 2 major drawbacks:</p>
<ul>
<li>Somewhere in the app code might have <code>UIView.setAnimationsEnabled(true)</code> to enable animations. Then, the problem happens again.</li>
<li>Many things in the app simply do not work without animations.</li>
</ul>
<p>The second approach is to <strong>suppress the waiting behavior</strong>. In case of testing with <a href="https://appium.io/">Appium</a>, there is an option called <code>appium:waitForQuiescence</code> in the <a href="https://github.com/appium/appium-xcuitest-driver#desired-capabilities">desired capabilities</a> to achieve this. Unfortunately, XCTest does not have a public API to do so. Appium makes it work simply by swizzling the corresponding function of <code>XCUIApplicationProcess</code> (a private class in XCTest) (see: <a href="https://github.com/appium/WebDriverAgent/blob/e1c9635/WebDriverAgentLib/Categories/XCUIApplicationProcess+FBQuiescence.m#L20-L39">here</a>) and doing nothing if the option <code>appium:waitForQuiescence</code> is <code>false</code>. If not using Appium, we can also use the same approach.</p>
<h3 id="34-time-sensitive-datanon-deterministic-behaviors">3.4. Time-sensitive Data/Non-deterministic Behaviors</h3>
<p>If a feature is time-dependant, what we see might depend on the time we execute tests. For example, if a UI component displays differently during daytime or nighttime, tests might fail because the assertion assumes it is daytime while the actual result corresponds to nighttime.</p>
<p>Another notorious time-sensitive data is <strong>timezone</strong>. When writing tests, engineers often overlook this aspect because most of the time, everyone in the team is in the same timezone. But when their team expands to not just one country, the problem arises. Consider the following example:</p>
<ul>
<li>A Singapore-based engineer writes a test with a fixed time (8:00 AM 2022-06-25, local time).</li>
<li>He/she then asserts seeing &ldquo;8:00 AM&rdquo; in the test, assuming that the UI always displays &ldquo;8:00 AM&rdquo; as it is using a fixed time.</li>
<li>This change bypasses CI as the runners are configured with Singapore timezone (GMT +8:00).</li>
<li>Then a Jakarta-based engineer runs this test and gets a failure because he is seeing &ldquo;7:00 AM&rdquo; instead of &ldquo;8:00 AM&rdquo;.</li>
</ul>
<p>In this example, the UI in the 2 timezones are just slightly different. But when we have Seattle engineers (GMT -7:00) contributing to the project, what they see in the app might differ considerably as the local date in Seattle is 2022-06-24 (not 2022-06-25).</p>
<p>Given this annoying disprepancy, many teams usually choose to <strong>agree on a default timezone</strong> to save the maintenance effort.</p>
<h3 id="35-deviceos-variants">3.5. Device/OS Variants</h3>
<p>When testing on different device models, we might run into the issue in which an element is visible on iPhone X while it is not on iPhone 7. This frequently happens with table views or scroll views. Therefore, sometimes we need to perform extra swipes/scrolls to make sure the element is in the visible area of the screen.</p>
<p>There are two common failures when running tests on different iOS versions:</p>
<ul>
<li>In certain iOS versions, the accessibility IDs/labels of some components are not deterministics. For example, when scrolling a component, the element type of its contents might change (see: <a href="https://developer.apple.com/forums/thread/106681">here</a>). This kind of weird issues seems to happen more with table views and collection views which have the built-in resuable behavior.</li>
<li>Some system UI components might change. Examples would be <em>notification banners</em>, or <em>permission alerts</em>.</li>
</ul>
<p>Similar to the approach to different timezones, we can <strong>agree on a fixed device model and iOS version</strong>. Yet, it is a bit difficult to stick to an iOS version on CI for all Xcode versions because:</p>
<ul>
<li>By default, we only have an iOS runtime that is shipped together with Xcode. For example, with Xcode 12.0 we get iOS 14.0, with Xcode 13.0 we get iOS 15.0.</li>
<li>Installing other iOS runtimes for CI runners is not straightforward especially when the team does not have full control over the runners.</li>
</ul>
<p>This explains why Xcode migration occasionally involves fixing UI/unit/snapshot tests. The most noticeable failed tests are those having table/collection views because a new iOS release usually changes themes of those components.</p>
<h2 id="4-dealing-with-flakiness">4. Dealing With Flakiness</h2>
<p>The measures in this section correspond to 3 stages: <strong>before</strong>, <strong>while</strong>, and <strong>after</strong> flakiness is introduced.</p>
<h3 id="41-preventing-flakiness">4.1. Preventing Flakiness</h3>
<p>During development, we should anticipate possible flakiness and make our code robust. We need to take into consideration the contributing factors mentioned above. The measures to mitigate each of those factors were already discussed in the previous section.</p>
<h3 id="42-troubleshooting-flakiness">4.2. Troubleshooting Flakiness</h3>
<p>When we have flakiness, engineers jump in to investigate and fix the issue. The ability to easily troubleshoot issues matters. As follows are some suggestions to help engineers identify the issues faster.</p>
<h4 id="processing-the-xcresult-bundle">Processing the <code>.xcresult</code> Bundle</h4>
<p>Normally, after running tests, we can just open the reports navigator (in Xcode) to view test results. We can also open the <code>.xcresult</code> bundle (produced when a test session is finished) with Xcode to quickly open this UI.</p>
<img src="/images/ios/test_reports_navigator.png" width=500>
<figcaption>Fig. Details of a failed tests in the reports navigator in Xcode.</figcaption>
<p>This UI displays quite some useful data for further investigation such as screenshots, and app UI hierarchy. However, the logs of the host app which should reveal much about the root cause are hidden from the UI. Also, when running many tests in one session (this is usually the case for CI), opening the produced <code>.xcresult</code> bundle in Xcode is really laggy, causing a very bad developer experience.</p>
<p>Therefore, to provide the best troubleshoot experience, we need to <strong>extract useful data (for investigation) from the <code>.xcresult</code> bundle</strong>. Those data include app logs (both the runner app and the host app), screenshots, attachments, etc. They can be easily extracted using <a href="https://github.com/ChargePoint/xcparse">xcparse</a>. Alternatively, we can use <code>xcresulttool</code> (which xcparse is using under the hood) to obtain those data ourselves.</p>
<h4 id="segregating-per-test-data">Segregating per-Test Data</h4>
<p>On CI, many tests are executed in the same session. Some data such as app logs are consolidated for all tests.</p>
<p>It is best to have <strong>artifacts of each test</strong> separately. This way, we only care about what happened for the test of interest only.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">artifacts / MyTestTarget / MyTestClass / testFunction1 / -- screenshot.png
                                                         -- host_app_hierarchy.txt
                                                         -- host_app.txt
                                                         -- runner_app.txt
                                       / testFunction2
</code></pre></div><p>Logs in the runner app are well structured. With some regexes, we can easily extract logs of a specific test from the consolidated logs.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">Test Case &#39;-[EXUITests.EXUITests testX1]&#39; started.
...
Test Case &#39;-[EXUITests.EXUITests testX1]&#39; failed (4.568 seconds).
...
Test Case &#39;-[EXUITests.EXUITests testX2]&#39; started.
...
Test Case &#39;-[EXUITests.EXUITests testX2]&#39; passed (3.528 seconds).
</code></pre></div><p>Meanwhile, logs in the host app do not indicate what test it is running against. One trick to have that info is to <strong>pass the test name via launch environment</strong> when launching the app. After that, we can use regexes to extract relevant logs.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// In the app target</span>
<span class="kd">class</span> <span class="nc">AppDelegate</span><span class="p">:</span> <span class="n">UIResponder</span><span class="p">,</span> <span class="n">UIApplicationDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="n">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span> <span class="n">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="n">UIApplication</span><span class="p">.</span><span class="n">LaunchOptionsKey</span><span class="p">:</span> <span class="nb">Any</span><span class="p">]?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">testName</span> <span class="p">=</span> <span class="n">ProcessInfo</span><span class="p">.</span><span class="n">processInfo</span><span class="p">.</span><span class="n">environment</span><span class="p">[</span><span class="s">&#34;TEST_NAME&#34;</span><span class="p">]</span> <span class="p">{</span>
      <span class="bp">print</span><span class="p">(</span><span class="s">&#34;Test started: </span><span class="si">\(</span><span class="n">testName</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// In the test target</span>
<span class="kd">class</span> <span class="nc">BaseTestCase</span><span class="p">:</span> <span class="n">XCTestCase</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nv">app</span> <span class="p">=</span> <span class="n">XCUIApplication</span><span class="p">()</span>
  <span class="kr">override</span> <span class="kd">func</span> <span class="nf">setUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">setUp</span><span class="p">()</span>
    <span class="n">app</span><span class="p">.</span><span class="n">launchEnvironment</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#34;TEST_NAME&#34;</span><span class="p">:</span> <span class="kc">self</span><span class="p">.</span><span class="n">name</span><span class="p">]</span> <span class="c1">// &lt;-- inject the value</span>
    <span class="n">app</span><span class="p">.</span><span class="n">launch</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Regarding attachments and screenshots, xcparse does not group them by test. Extra effort (patching xcparse/wrapping xcresulttool) is needed to place them in the respective test dirs. One trick to avoid this effort is to manually collect the screenshot and UI hierarchy in the <a href="https://developer.apple.com/documentation/xctest/xctestcase/3546549-record"><code>record(_:)</code> function</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="nc">BaseTestCase</span><span class="p">:</span> <span class="n">XCTestCase</span> <span class="p">{</span>
  <span class="kr">override</span> <span class="kd">func</span> <span class="nf">record</span><span class="p">(</span><span class="kc">_</span> <span class="n">issue</span><span class="p">:</span> <span class="n">XCTIssue</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;Host app:</span><span class="se">\n</span><span class="si">\(</span><span class="n">app</span><span class="p">.</span><span class="n">debugDescription</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>           <span class="c1">// &lt;-- Dump App UI hierarchy to the console</span>
    <span class="n">app</span><span class="p">.</span><span class="n">screenshot</span><span class="p">().</span><span class="n">pngRepresentation</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">testDir</span><span class="p">)</span> <span class="c1">// &lt;-- Save screenshot to the test dir</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">record</span><span class="p">(</span><span class="n">issue</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="43-fixing-flakiness">4.3. Fixing Flakiness</h3>
<h4 id="benchmarking-tests">Benchmarking Tests</h4>
<p>When fixing a flaky test, we need to ensure the test is stable enough before merging the fix. Therefore, it is useful to <strong>benchmark the test on CI</strong>.</p>
<p>We have a CI feature that an engineer can benchmark tests on his/her merge requests by specifying the instructions in the merge request description.</p>
<div class="highlight"><pre class="chroma"><code class="language-md" data-lang="md">This merge request aims to fix <span class="sb">`testFunction1`</span> and <span class="sb">`testFunction2`</span>.

Benchmark: MyTestTarget/MyTestClass/testFunction1 x10
Benchmark: MyTestTarget/MyTestClass/testFunction2 x5
</code></pre></div><p>In the sample merge request description above, the line <code>Benchmark: MyTestTarget/MyTestClass/testFunction1 x10</code> directs CI to benchmark the test <code>testFunction1</code> 10 times.</p>
<p>To get the list of tests to benchmark in this example, we can send an API request to get the merge request description, then apply some regexes. The benchmark can be done with <a href="https://www.avanderlee.com/debugging/flaky-tests-test-repetitions/">test repetitions</a> (introduced since Xcode 13), or simply by running <code>xcodebuild</code> multiple times with the given tests.</p>
<h3 id="44-living-with-flakiness">4.4. Living With Flakiness</h3>
<p>As mentioned ealier, flakiness is always part of the system. Zero-tolerance against flakiness would lead to a very bad developer experience. Consider the following scenario:</p>
<ul>
<li>A test has been added to the project. It succeeds consistently.</li>
<li>One day, it fails intermittently on CI for some reasons. This prevents some engineers from merging their changes. Those engineers have to retry the jobs, hoping that it shall pass in the retry.</li>
<li>Someone in the team has to take actions, to either investigate the flakiness, or temporarily disable that test.</li>
</ul>
<p>The costs in the above scenario are:</p>
<ul>
<li><em>Maintenance effort</em> of the test owners (not to mention that this effort comes in form of ad-hoc tasks which might intervene in team process).</li>
<li><em>Waiting time</em> of the affected engineers.</li>
<li><em>Communication effort</em> between the affected engineers and the test owners.</li>
</ul>
<p>Therefore, we need to design our CI system in a way that flakiness should have minimal impacts on deverloper experiences.</p>
<h4 id="retrying-failed-tests">Retrying Failed Tests</h4>
<p>This is the most common approach to live with flaky tests. Failed tests will go through several retries. The number of retries might be different for each project. The more retries we have, the longer time it takes to finish the job.</p>
<h4 id="test-success-rate">Test Success Rate</h4>
<p>The success rate of a test is defined as the number of successful attempts over the total number of attempts. If a test succeeds 9 out of 10 times, its success rate is 0.9.</p>
<p>This success rate is the key metric to evaluate how flaky a test is. A test is considered flaky if its success rate falls below a certain threshold.</p>
<p>Note that not all test executions are reliable. If a test fails on a merge request, the failure might be due to the change instead. Data in some following cases can be used:</p>
<ul>
<li>(1) Tests succeeding or failing on the main branches.</li>
<li>(2) Tests succeeding on merge requests.</li>
<li>(3) Tests failing in one job and then succeeding when (manually) retrying that job.</li>
</ul>
<h4 id="test-quarantine-logic">Test quarantine Logic</h4>
<p>A flaky test is <strong>quarantined</strong> if its result (success/failure) does not affect the overall result of the job. If all failed tests are quarantined, we are good to go.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback">--[execute &amp; retry]--&gt; failed --[quarantine] --&gt; all quarantined --&gt; passed
                                           | --&gt; otherwise --&gt; failed
</code></pre></div><p>To integrate this quarantine logic, we need to have the stats (test success rates&hellip;) of all tests in the project for the past N days. Such stats data is generated from the executions from the project.</p>
<img src="/images/ios/quarantine.png" width=600>
<figcaption>Fig. How quarantine logic is involved in deciding the overall result.</figcaption>
<p>By introducing the quarantine logic, we create an auto feedback loop into the development process:</p>
<ul>
<li>When a test becomes flaky, its success rate decreases. The quarantine for this test is in effect.</li>
<li>When this test stabilizes, it success rate increases. Then the quarantine is lifted for this test.</li>
</ul>
<p>The stats used in the quarantine logic can just be a json file hosted anywhere as long as we can download it. The storage could be an S3 bucket, or a git repo.</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;MyTestTarget/MyTestClass/testFunction1&#34;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span>
  <span class="nt">&#34;MyTestTarget/MyTestClass/testFunction2&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nt">&#34;MyTestTarget/MyTestClass/testFunction3&#34;</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>The whole process from test data submission to stats generation is pretty much like an <a href="https://en.wikipedia.org/wiki/Extract,_transform,_load">ETL pipeline</a>. So, you can choose any implementation that fits your need. For us, we use a git repo to reduce the effort for <a href="https://en.wikipedia.org/wiki/Identity_management">Identity Access Management (IAM)</a>. Let&rsquo;s discuss the detailed setup with a git repo in the upcoming posts.</p>
<h2 id="5-conclusion">5. Conclusion</h2>
<p>In this post, we cover some background of UI testing and what contributes to test flakiness. Some flakiness can be prevented in the early stage when writing tests and developing features. Despite our prevention measures, flakiness will always persist. Therefore, a long term approach to cope with flakiness should focus on improving troubleshoot experiences, bug fixing experiences, and making flakiness tolerated.</p>

  <div class="entry-footer">
  
<div class="categories">
  <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>

  
  <a href="/categories/Tech" class="category">Tech</a>
  
</div>

  
<div class="tags">
  <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>

  
  <a href="/tags/ci" class="tag">ci</a>
  
  <a href="/tags/ios" class="tag">ios</a>
  
</div>

</div>
</article>


<nav class='entry-nav'><div class='prev-entry'>
    <a href='/posts/tech/ci-extract-test-methods/'>CI: Heuristically Extracting Test Methods Before Runtime</a>
  </div><div class='next-entry'>
    <a href='/posts/tech/cocoapods-explained-podfile/'>CocoaPods Explained: Podfile</a>
  </div></nav>


<section id='comments' class='comments'>
  
  
  <div class="container">
    <div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v5.0"></script>
<div class="share">
  <div class="fb-like" data-href="https://trinhngocthuyen.github.io/posts/tech/dealing-with-flaky-ui-tests/" data-width="" data-layout="standard" data-action="like" data-share="true"></div>
</div>

  </div>
  
  
  <div class="container">
    
  </div>
</section>


</main></body>
</html>